---
description: Action rule to create a well-structured changelog document capturing meaningful engineering work on Tekton Hub, sized proportionally to the feature's impact and complexity.
globs: []
alwaysApply: false
---

# Rule: Create Tekton Hub Changelog (action)

Purpose: When invoked, create a comprehensive changelog document in the `_changelog/` directory that captures the essence, context, and impact of recent engineering work on Tekton Hub. The changelog should be meaningful, well-structured, and appropriately sized based on the scope and impact of the change.

Usage: Invoke explicitly as `@create-tekton-hub-changelog` after completing meaningful work in a conversation.

References: `@understand-cursor-rules`, existing changelogs in `_changelog/`

## ⚠️ CRITICAL: Explicit Invocation Only

**DO NOT** create a changelog automatically or proactively. Changelogs must ONLY be created when the user explicitly invokes this rule with `@create-tekton-hub-changelog`.

Never:
- ❌ Suggest creating a changelog without being asked
- ❌ Create a changelog at the end of a conversation automatically
- ❌ Assume the user wants a changelog created
- ❌ Create a changelog "to be helpful" without explicit request

Always:
- ✅ Wait for explicit `@create-tekton-hub-changelog` invocation
- ✅ Confirm the request before creating the file
- ✅ Let the user decide when/if a changelog is needed

**This is a user-controlled action, not an automatic process.**

## When to Create a Changelog

Create a changelog when:
- ✅ You've completed a meaningful feature, refactoring, or improvement
- ✅ The work involved multiple files or system components
- ✅ The change introduces new patterns or architectural decisions
- ✅ The work took significant time/effort (typically 1+ hours)
- ✅ The change has notable impact on Tekton Hub users, developers, or workflows
- ✅ You want to preserve the context and rationale for future reference
- ✅ New API endpoints or UI features were added
- ✅ Task or pipeline management was enhanced
- ✅ Database schema or migration was modified

**Skip changelogs for**:
- ✋ Trivial bug fixes or typo corrections
- ✋ Minor configuration tweaks
- ✋ Work-in-progress or incomplete changes
- ✋ Changes already well-documented in PR descriptions

## Sizing Guidance: Use Your Judgment

**Critical principle**: The changelog length should be **proportional to the feature's complexity and impact**, not artificially constrained or inflated.

### Small Changes (150-300 lines)
- Single API endpoint updates
- Focused bug fixes with clear before/after
- Minor UI enhancements
- Configuration improvements
- Single task or pipeline updates

**Example**: API error reporting enhancement - straightforward problem, clear solution, limited scope

### Medium Changes (300-600 lines)
- Multi-component refactorings
- New feature patterns
- Database migrations
- Integration work across API and UI
- Changes across 2-3 components

**Example**: Task validation framework - new pattern, multiple endpoints, clear architecture

### Large Changes (600-1000+ lines)
- Major architectural shifts
- Framework migrations
- Comprehensive feature rollouts across many tasks
- System-wide refactorings with broad impact
- New task execution patterns

**Example**: Generic task operations (multiple task types), Complete API restructuring, Task framework overhaul

**Golden rule**: If you're unsure, start shorter and add detail only where it adds real value. Quality over quantity.

## Changelog Structure

### File Naming
```
YYYY-MM-DD-HHMMSS-brief-descriptive-slug.md
```

Examples:
- `2025-11-23-153045-task-validation-framework.md`
- `2025-11-23-091230-api-rate-limiting-support.md`
- `2025-11-22-164500-ui-task-list-pagination-fix.md`

**IMPORTANT**: Get the actual current timestamp by running the command `date +"%Y-%m-%d-%H%M%S"` and use that exact output as the prefix for the filename. Do NOT make up or guess the timestamp. Follow with a clear, kebab-case slug describing the change. The timestamp (HHMMSS) ensures automatic chronological sorting when multiple changelogs are created on the same day.

### Required Metadata

Every changelog should start with metadata in this format:

```markdown
# [Clear, Descriptive Title]

**Date**: [Month Day, Year]
**Type**: [Enhancement | Bug Fix | Feature | Refactoring | Breaking Change]
**Components**: [Component1, Component2, Component3]

## Summary

[2-4 sentence overview of what was accomplished and why it matters]
```

**Common Components**:
- API
- UI
- Database
- Task Management
- Pipeline Management
- Authentication
- Configuration
- Build System
- Error Handling
- User Experience

### Required Sections

Every changelog should include:

```markdown
# [Clear, Descriptive Title]

**Date**: [Month Day, Year]
**Type**: [Type]
**Components**: [Components]

## Summary

[2-4 sentence overview of what was accomplished and why it matters]

## Problem Statement / Motivation

[Describe the problem or need that motivated this work]

### Pain Points

[Bullet list of specific issues being addressed]

## Solution / What's New

[High-level description of the approach taken]

### [Key Features/Components]

[Visual diagrams, component descriptions as needed]

## Implementation Details

[Technical specifics - code changes, new patterns, key decisions]

## Benefits

[Concrete improvements - metrics, time savings, developer experience]

## Impact

[Who/what is affected and how]

## Related Work

[Connect to other changelogs, features, or initiatives]

---

**Status**: ✅ [Production Ready | In Progress | Experimental]
**Timeline**: [Duration if relevant]
```

### Optional Sections (Include When Valuable)

Add these sections only when they provide meaningful value:

- **Breaking Changes**: When APIs, endpoints, or contracts change incompatibly
- **Migration Guide**: When users need to adapt their workflows
- **Testing Strategy**: For complex features requiring verification
- **Performance Characteristics**: When performance is a key concern
- **Known Limitations**: For incomplete implementations
- **Future Enhancements**: For planned follow-up work
- **Usage Examples**: When it helps understanding (API calls, UI workflows)
- **Code Metrics**: Statistics that tell a story (files changed, reduction %, etc.)
- **Design Decisions**: When trade-offs were significant
- **Architecture**: When system design changed
- **Backward Compatibility**: When compatibility considerations are important
- **Security Considerations**: For security-related changes

## Writing Guidelines

### Do:
- ✅ **Start with context**: Why did this work happen?
- ✅ **Focus on value**: What problem does this solve for Tekton Hub users?
- ✅ **Use concrete examples**: Show before/after API calls, UI screenshots, outputs
- ✅ **Include numbers**: Metrics, timelines, file counts (when meaningful)
- ✅ **Explain decisions**: Why this approach vs alternatives?
- ✅ **Write for future you**: Capture the thinking, not just the what
- ✅ **Link to related work**: Connect the dots with other changes
- ✅ **Use formatting**: Code blocks, tables, bullet lists for readability
- ✅ **Show actual output**: API responses, UI states, error messages

### Don't:
- ❌ **Over-explain the obvious**: Assume the reader is technical
- ❌ **Include every detail**: Focus on what matters
- ❌ **Write generic summaries**: Be specific to Tekton Hub
- ❌ **Skip the "why"**: Context is critical for future understanding
- ❌ **Ignore trade-offs**: Document decisions and their rationale
- ❌ **Use jargon without context**: Define terms that may be unclear

## Tone and Style

- **Informative, not promotional**: Focus on facts and impact
- **Technical but accessible**: Balance depth with clarity
- **Professional but human**: You can say "we struggled with X" or "this was tricky"
- **Present tense for descriptions**: "The API now does X"
- **Past tense for actions**: "We implemented Y"

## Quality Checklist

Before finalizing a changelog:

- [ ] Title clearly describes the change
- [ ] Metadata includes Date, Type, and Components
- [ ] Summary captures essence in 2-4 sentences
- [ ] Problem statement explains why work was needed
- [ ] Solution section describes the approach
- [ ] Implementation details are technical but focused
- [ ] Benefits are concrete and measurable
- [ ] Code examples (if any) are actual code, not pseudocode
- [ ] API examples and outputs are copy-pasteable
- [ ] Related work connects this to other changes
- [ ] Length is proportional to scope and impact
- [ ] No sensitive information (credentials, private URLs, etc.)
- [ ] File paths reference actual tekton-hub structure

## Proportionality Examples

### ✅ Good: Appropriately Sized

**Small feature** (200 lines): 
- Problem: 1 paragraph
- Solution: 1-2 paragraphs + key code snippet or API example
- Benefits: 3-5 bullets
- Impact: 1 paragraph

**Medium feature** (500 lines):
- Problem: 2-3 paragraphs with pain points
- Solution: Component descriptions with examples
- Implementation: 3-4 key changes with code snippets
- Benefits: Categorized list with metrics
- Impact: User experience + developer improvements

**Large feature** (900 lines):
- Problem: Comprehensive context with examples
- Solution: Full architecture with diagrams and phases
- Implementation: Detailed technical sections per component
- Benefits: Quantitative and qualitative analysis
- Testing: Strategy and verification steps
- Impact: Multi-dimensional (users, developers, operations)

### ❌ Anti-patterns

- **Over-detailed small change**: 800-line changelog for a 50-line fix
- **Under-documented major change**: 150-line changelog for major refactor
- **Kitchen sink**: Including every file touched, every line changed
- **Too abstract**: Generic descriptions without concrete examples

## Tekton Hub Specific Guidelines

### File Path Examples

When referencing code, use actual tekton-hub paths:

```markdown
**File**: `api/pkg/service/task/task.go`
**File**: `ui/src/components/TaskList/TaskList.tsx`
**File**: `db/migrations/000001_create_tasks_table.sql`
**File**: `config/config.yaml`
```

### API Endpoint Examples

Always show actual API calls users can make:

```bash
# Get task list
curl -X GET https://api.hub.tekton.dev/v1/tasks

# Create new task
curl -X POST https://api.hub.tekton.dev/v1/tasks \
  -H "Content-Type: application/json" \
  -d '{"name": "example-task", "version": "1.0.0"}'

# Validate task
curl -X POST https://api.hub.tekton.dev/v1/tasks/validate \
  -H "Content-Type: application/json" \
  -d @task.json
```

### Component Categories

Use these component categories consistently:

**API Layer**:
- API, Authentication, Task Management, Pipeline Management

**UI Layer**:
- UI, User Experience, Components

**Data Layer**:
- Database, Migrations, Data Models

**Infrastructure**:
- Configuration, Build System, CI/CD

**Cross-cutting**:
- Error Handling, Logging, Testing, Security

## Automation Notes

When creating the changelog:
1. **Get current timestamp**: Run `date +"%Y-%m-%d-%H%M%S"` to get the actual current date and time for the filename
2. **Analyze the conversation**: Extract key decisions, changes, outcomes
3. **Assess scope**: Count files, endpoints, components affected
4. **Determine components**: Map changes to component categories
5. **Choose type**: Enhancement, Bug Fix, Feature, Refactoring, Breaking Change
6. **Size appropriately**: Match detail level to impact
7. **Write the file**: Create in `_changelog/YYYY-MM/` (year-month directory) with proper naming using the timestamp from step 1
8. **Confirm creation**: Provide file path and next steps

## Example Invocations

```
"We just completed the task validation framework. @create-tekton-hub-changelog"

"I've finished implementing the API rate limiting across all endpoints. 
@create-tekton-hub-changelog - this was a significant security enhancement"

"The UI task list pagination refactoring is done. @create-tekton-hub-changelog - 
include the performance improvements we measured"
```

## Remember

**Changelogs are living documentation** that helps future developers (including you) understand:
- What changed in Tekton Hub
- Why it changed
- How it was implemented
- What the impact was on users

Write for the person who will debug this at 2am in six months. Give them the context they need - no more, no less.

**When in doubt**: Start with the required sections, keep it focused, and add detail only where it truly helps understanding. A clear, concise 300-line changelog is better than a rambling 1000-line document.

---

*"Documentation is a love letter to your future self."* - Damian Conway
